# 消息系統和雙提示功能開發方案

## 一、需求分析

### 1.1 雙提示系統需求
- **Miniapp 內部提示**：用戶在 miniapp 中時，使用自定義彈窗顯示
- **Telegram 提示**：用戶關閉 miniapp 時，通過 Telegram Bot 發送消息
- **用戶控制**：允許用戶選擇提示方式（僅 miniapp / 雙提示 / 關閉提示）
- **智能判斷**：自動檢測用戶是否在 miniapp 中

### 1.2 消息中心需求
- **星星圖標增強**：在星星左邊顯示未讀消息數量徽章
- **紅點提示**：有未讀消息時顯示小紅點
- **消息面板**：點擊星星進入消息中心
- **消息功能**：查看、刪除、回復消息
- **消息來源**：
  - Miniapp 內部消息（系統通知、活動通知等）
  - Telegram 消息（Bot 發送的消息）
  - 機器人消息（自動化消息）
  - 系統消息（紅包通知、餘額變動等）

## 二、技術架構設計

### 2.1 數據庫設計

#### 2.1.1 消息表 (messages)
```python
class MessageType(str, enum.Enum):
    SYSTEM = "system"          # 系統消息
    MINIAPP = "miniapp"        # Miniapp 內部消息
    TELEGRAM = "telegram"      # Telegram Bot 消息
    BOT = "bot"                # 機器人自動消息
    REDPACKET = "redpacket"    # 紅包相關
    BALANCE = "balance"        # 餘額變動
    ACTIVITY = "activity"     # 活動通知

class MessageStatus(str, enum.Enum):
    UNREAD = "unread"
    READ = "read"
    DELETED = "deleted"

class Message(Base):
    __tablename__ = "messages"
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
    message_type = Column(Enum(MessageType), nullable=False)
    status = Column(Enum(MessageStatus), default=MessageStatus.UNREAD)
    
    title = Column(String(256), nullable=True)
    content = Column(Text, nullable=False)
    action_url = Column(String(512), nullable=True)  # 點擊後跳轉的鏈接
    
    # 來源信息
    source = Column(String(64), nullable=True)  # 來源標識（bot_id, system, etc.）
    source_name = Column(String(128), nullable=True)  # 來源名稱
    
    # 回復相關
    reply_to_id = Column(Integer, ForeignKey("messages.id"), nullable=True)
    can_reply = Column(Boolean, default=False)
    
    # 元數據
    metadata = Column(JSON, nullable=True)  # 存儲額外數據（如紅包ID、金額等）
    
    # 時間戳
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    read_at = Column(DateTime, nullable=True)
    deleted_at = Column(DateTime, nullable=True)
    
    # 關聯
    user = relationship("User", back_populates="messages")
    reply_to = relationship("Message", remote_side=[id])
```

#### 2.1.2 用戶通知設置表 (user_notification_settings)
```python
class UserNotificationSettings(Base):
    __tablename__ = "user_notification_settings"
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"), unique=True, nullable=False)
    
    # 提示方式設置
    notification_method = Column(String(32), default="both")  # "miniapp_only", "both", "telegram_only", "off"
    
    # 各類型消息的開關
    enable_system = Column(Boolean, default=True)
    enable_redpacket = Column(Boolean, default=True)
    enable_balance = Column(Boolean, default=True)
    enable_activity = Column(Boolean, default=True)
    enable_miniapp = Column(Boolean, default=True)
    enable_telegram = Column(Boolean, default=True)
    
    # 更新時間
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

### 2.2 後端 API 設計

#### 2.2.1 消息相關 API (`api/routers/messages.py`)
```python
# GET /api/v1/messages - 獲取消息列表
# GET /api/v1/messages/unread-count - 獲取未讀消息數量
# GET /api/v1/messages/{message_id} - 獲取單條消息詳情
# PUT /api/v1/messages/{message_id}/read - 標記為已讀
# DELETE /api/v1/messages/{message_id} - 刪除消息
# POST /api/v1/messages/{message_id}/reply - 回復消息
# GET /api/v1/messages/settings - 獲取通知設置
# PUT /api/v1/messages/settings - 更新通知設置
```

#### 2.2.2 消息發送服務 (`api/services/message_service.py`)
```python
class MessageService:
    """消息發送服務 - 統一管理所有消息發送"""
    
    async def send_message(
        self,
        user_id: int,
        message_type: MessageType,
        content: str,
        title: Optional[str] = None,
        action_url: Optional[str] = None,
        send_telegram: Optional[bool] = None,  # None 表示根據設置自動判斷
        metadata: Optional[dict] = None
    ):
        """
        發送消息的核心方法
        - 如果用戶在 miniapp 中：在 miniapp 中顯示
        - 如果用戶不在 miniapp 中：通過 Telegram Bot 發送
        - 根據用戶設置決定是否發送
        """
        pass
```

### 2.3 前端設計

#### 2.3.1 消息中心組件 (`frontend/src/pages/MessagesPage.tsx`)
- 消息列表（分組顯示：未讀/已讀）
- 消息詳情查看
- 刪除功能
- 回復功能
- 標記已讀

#### 2.3.2 通知設置組件 (`frontend/src/components/NotificationSettings.tsx`)
- 提示方式選擇（僅 miniapp / 雙提示 / 僅 Telegram / 關閉）
- 各類型消息開關

#### 2.3.3 TopToolbar 增強
- 星星左邊顯示未讀數量徽章
- 小紅點提示
- 點擊星星打開消息面板

#### 2.3.4 雙提示管理器 (`frontend/src/utils/notification.ts`)
```typescript
class NotificationManager {
  // 檢測用戶是否在 miniapp 中
  isInMiniapp(): boolean
  
  // 發送提示（自動判斷方式）
  notify(message: string, type: 'success' | 'error' | 'warning' | 'info'): Promise<void>
  
  // 僅在 miniapp 中提示
  notifyInMiniappOnly(message: string, type: string): Promise<void>
  
  // 通過 Telegram 發送（如果用戶不在 miniapp 中）
  notifyViaTelegram(message: string): Promise<void>
}
```

### 2.4 Bot 集成

#### 2.4.1 消息發送功能 (`bot/services/message_sender.py`)
- 通過 Telegram Bot API 發送消息給用戶
- 支持富文本格式
- 支持按鈕和鏈接

## 三、開發步驟

### 階段一：數據庫和後端基礎（1-2天）
1. ✅ 創建消息表和通知設置表
2. ✅ 創建消息相關 API 路由
3. ✅ 實現消息 CRUD 操作
4. ✅ 實現通知設置 API

### 階段二：消息發送服務（1-2天）
1. ✅ 創建 MessageService
2. ✅ 實現雙提示邏輯（檢測用戶狀態，選擇發送方式）
3. ✅ 集成 Telegram Bot 發送功能
4. ✅ 實現消息隊列（可選，用於批量發送）

### 階段三：前端消息中心（2-3天）
1. ✅ 創建 MessagesPage 組件
2. ✅ 實現消息列表、詳情、刪除、回復功能
3. ✅ 創建 NotificationSettings 組件
4. ✅ 增強 TopToolbar（星星徽章、紅點）

### 階段四：雙提示系統（1-2天）
1. ✅ 創建 NotificationManager
2. ✅ 實現用戶狀態檢測（WebSocket 或輪詢）
3. ✅ 集成到現有 showAlert/showConfirm
4. ✅ 實現通知設置 UI

### 階段五：集成和測試（1-2天）
1. ✅ 將消息功能集成到現有功能（紅包、餘額變動等）
2. ✅ 測試雙提示功能
3. ✅ 測試消息中心功能
4. ✅ 性能優化

## 四、技術細節

### 4.1 用戶狀態檢測
**方案 A：WebSocket（推薦）**
- 前端建立 WebSocket 連接
- 後端維護在線用戶列表
- 實時更新用戶狀態

**方案 B：輪詢**
- 前端定期發送心跳請求
- 後端記錄最後活躍時間
- 簡單但效率較低

**方案 C：Telegram WebApp 狀態**
- 使用 `window.Telegram.WebApp.isExpanded` 檢測
- 監聽 `viewportChanged` 事件
- 簡單但僅限於 miniapp 環境

### 4.2 消息推送策略
1. **實時推送**：用戶在線時立即推送
2. **批量推送**：離線消息累積後批量發送
3. **優先級**：重要消息（如紅包）優先發送

### 4.3 消息分類和過濾
- 按類型分組顯示
- 支持搜索和過濾
- 支持標記重要消息

## 五、API 接口設計

### 5.1 消息列表
```
GET /api/v1/messages
Query Params:
  - type: MessageType (可選)
  - status: MessageStatus (可選，默認 unread)
  - page: int (可選，默認 1)
  - limit: int (可選，默認 20)

Response:
{
  "total": 100,
  "page": 1,
  "limit": 20,
  "unread_count": 5,
  "messages": [
    {
      "id": 1,
      "type": "redpacket",
      "title": "紅包已領取",
      "content": "您領取了 10 USDT 紅包",
      "status": "unread",
      "created_at": "2025-11-28T10:00:00Z",
      "action_url": "/packets/123"
    }
  ]
}
```

### 5.2 未讀數量
```
GET /api/v1/messages/unread-count

Response:
{
  "unread_count": 5,
  "unread_by_type": {
    "redpacket": 2,
    "system": 1,
    "balance": 2
  }
}
```

### 5.3 標記已讀
```
PUT /api/v1/messages/{message_id}/read

Response:
{
  "success": true
}
```

### 5.4 刪除消息
```
DELETE /api/v1/messages/{message_id}

Response:
{
  "success": true
}
```

### 5.5 回復消息
```
POST /api/v1/messages/{message_id}/reply
Body:
{
  "content": "回復內容"
}

Response:
{
  "id": 2,
  "content": "回復內容",
  "created_at": "2025-11-28T10:05:00Z"
}
```

### 5.6 通知設置
```
GET /api/v1/messages/settings

Response:
{
  "notification_method": "both",
  "enable_system": true,
  "enable_redpacket": true,
  ...
}

PUT /api/v1/messages/settings
Body:
{
  "notification_method": "miniapp_only",
  "enable_redpacket": false,
  ...
}
```

## 六、前端組件結構

```
frontend/src/
├── components/
│   ├── MessagesPanel.tsx          # 消息面板（側邊欄或彈窗）
│   ├── MessageItem.tsx            # 消息列表項
│   ├── MessageDetail.tsx          # 消息詳情
│   ├── NotificationSettings.tsx   # 通知設置
│   └── MessageBadge.tsx           # 消息徽章（數量顯示）
├── pages/
│   └── MessagesPage.tsx           # 消息中心頁面
├── hooks/
│   ├── useMessages.ts              # 消息相關 hooks
│   └── useNotification.ts          # 通知相關 hooks
└── utils/
    ├── notification.ts             # 通知管理器
    └── websocket.ts                # WebSocket 連接管理
```

## 七、實現優先級

### 高優先級（核心功能）
1. ✅ 數據庫設計和遷移
2. ✅ 消息 CRUD API
3. ✅ 消息中心 UI（基本功能）
4. ✅ 星星徽章和紅點
5. ✅ 雙提示基礎功能

### 中優先級（增強功能）
1. ⚠️ 消息回復功能
2. ⚠️ 通知設置 UI
3. ⚠️ 消息分類和過濾
4. ⚠️ WebSocket 實時推送

### 低優先級（優化功能）
1. ⚠️ 消息搜索
2. ⚠️ 批量操作
3. ⚠️ 消息模板
4. ⚠️ 消息統計

## 八、注意事項

1. **性能考慮**：消息列表需要分頁，避免一次性加載過多
2. **隱私保護**：確保消息僅對應的用戶可見
3. **錯誤處理**：Telegram 發送失敗時的降級處理
4. **用戶體驗**：消息提示不應過於頻繁，避免打擾用戶
5. **數據清理**：定期清理已刪除的舊消息

## 九、測試要點

1. ✅ 消息創建和讀取
2. ✅ 雙提示功能（miniapp 和 Telegram）
3. ✅ 通知設置保存和應用
4. ✅ 消息刪除和回復
5. ✅ 未讀數量統計
6. ✅ 用戶狀態檢測
7. ✅ 多設備同步（如果支持）

